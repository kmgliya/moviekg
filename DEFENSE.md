# Подготовка к защите проекта MovieKG

## Часть 1. Рассказ «Что и как я делала» (пошагово)

Используй этот текст как основу для защиты — можешь говорить своими словами, но держи логику.

---

### 1. Постановка задачи

Мне нужно было сделать приложение для просмотра списка фильмов и детальной информации о выбранном фильме. Стек: TypeScript, Next.js, Axios, Zustand, React Query и Feature-Sliced Design.

---

### 2. Инициализация и структура

Сначала создала проект через `create-next-app` с TypeScript и Tailwind. Потом спроектировала структуру по **Feature-Sliced Design**:

- **shared** — общие модули (API-клиент, типы, утилиты)
- **entities** — сущность «фильм» (модель + API + UI)
- **features** — фича «поиск» (store + SearchBar)
- **widgets** — сложные блоки (Header, Hero, MovieList)
- **app** — страницы и layout

Так логика разделена по слоям, и зависимости идут только «вниз» (от app к shared).

---

### 3. API и работа с данными

В **shared/api/base.ts** настроила Axios-клиент для TMDB API: базовый URL, API-ключ, язык (ru-RU).  
В **entities/movie/api/movieApi.ts** описала методы:

- `getPopularMovies` — популярные фильмы
- `getTrendingMovies` — тренды недели (для Hero)
- `searchMovies` — поиск по названию
- `getMovieById` — детали фильма с актёрами

Все запросы идут через **React Query** — он даёт кеш, состояния loading/error и пагинацию.

---

### 4. Страница со списком фильмов

Использую **useInfiniteQuery**:

- Если поиск пустой — загружаю популярные фильмы
- Если есть запрос от 3 символов — поиск

Подгрузка при скролле реализована через **Intersection Observer**: когда блок внизу попадает в зону видимости, вызываю `fetchNextPage`.

Состояние поиска храню в **Zustand** (`useSearchStore`): query, setQuery, clearQuery. SearchBar пишет в стор с **debounce 500 ms**, чтобы не спамить API при каждом вводе.

---

### 5. Страница деталей фильма

Динамический роут **`/movie/[id]`** — в `page.tsx` читаю `id` из `useParams()`, передаю в `movieApi.getMovieById`. React Query кеширует результат. Показываю постер, жанры, описание, рейтинг, актёров (credits), бюджет и сборы. Обрабатываю loading и error.

---

### 6. Hero и модалка

Hero подгружает первый тренд через `getTrendingMovies`.  
**Start Watching** ведёт на страницу фильма.  
**More Details** открывает модалку с кратким описанием и кнопкой «Go to movie page».

---

### 7. Тема (светлая/тёмная)

Храню тему в Zustand с **persist** (localStorage). При смене темы добавляю/убираю класс `dark` на `document.documentElement`. Tailwind настроен на `darkMode: 'class'`, поэтому `dark:` стили работают корректно.

---

### 8. Обработка ошибок и UX

- Спиннер при загрузке
- Сообщения при ошибке API
- Пустой результат при отсутствии данных
- Адаптивная вёрстка (mobile-first)
- Заглушка для постеров без изображения

---

## Часть 2. Возможные вопросы и ответы

### Архитектура и FSD

**Почему выбрала Feature-Sliced Design?**  
Чтобы разделить ответственность по слоям и уменьшить связанность. Слой может зависеть только от нижележащих (app → widgets → features → entities → shared). Так проще добавлять фичи и рефакторить.

**Что такое слой entities и чем он отличается от features?**  
Entities — базовые бизнес-сущности (фильм, пользователь). Features — действия и сценарии (поиск, добавление в избранное). Entity «фильм» описывает структуру данных, feature «поиск» — логику и UI поиска.

**Почему API в entities, а не в shared?**  
API специфичен для сущности «фильм» и работает с её типами. В shared лежат только общие вещи: базовый клиент, типы, утилиты.

---

### React Query

**Зачем использовать React Query, если можно просто fetch в useEffect?**  
React Query даёт кеширование, автоматический retry, состояния isLoading / isError, фоновое обновление и меньше бойлерплейта. Не нужно вручную управлять loading и error.

**Что такое staleTime и зачем он нужен?**  
Время, в течение которого данные считаются «свежими». Пока данные свежие, React Query не делает повторный запрос. У меня staleTime 1 минута — уменьшает количество запросов к API при переключении между страницами.

**Почему useInfiniteQuery, а не обычный useQuery с пагинацией?**  
useInfiniteQuery хранит все загруженные страницы в `data.pages` и возвращает `fetchNextPage`. Это удобно для бесконечного скролла: подгружаем следующую страницу, когда пользователь доскроллил до конца.

---

### Zustand

**Когда использовать Zustand, а когда React Query?**  
Zustand — для клиентского состояния (UI, настройки пользователя). React Query — для серверного (данные с API). Поисковый запрос и тема — клиентское, поэтому Zustand.

**Зачем persist для темы?**  
Чтобы выбранная тема сохранялась между сессиями. Zustand persist пишет стейт в localStorage и восстанавливает при загрузке страницы.

---

### Next.js и роутинг

**Почему App Router, а не Pages Router?**  
App Router — новый стандарт Next.js с layout, server components и вложенными роутами. Проект создан на его основе.

**Как работает динамический роут `/movie/[id]`?**  
Папка `[id]` создаёт динамический сегмент. В `page.tsx` я получаю `id` через `useParams()` и подставляю его в API-запрос.

**Что такое «use client» и где его ставлю?**  
Директива для Client Components — компонентов с хуками, event handlers, браузерными API. Без неё компонент считается Server Component. Я ставлю «use client» в providers, SearchBar, MovieList, Hero, ThemeToggle и на странице деталей.

---

### Axios и TMDB API

**Почему Axios, а не fetch?**  
Axios удобнее: interceptors, автоматическая сериализация, отмена запросов. По ТЗ требовался Axios.

**Как устроен API-клиент?**  
В base.ts создаю `axios.create` с `baseURL` TMDB, добавляю `api_key` и `language: ru-RU` в params по умолчанию. В movieApi вызываю `apiClient.get()` с нужными endpoints и параметрами.

---

### Debounce и поиск

**Зачем debounce в поиске?**  
Чтобы не отправлять запрос при каждом вводе символа. Ждём 500 ms после последнего ввода и только тогда обновляем query в сторе и вызываем API.

**Почему минимально 3 символа для поиска?**  
Сократить количество слишком общих запросов и нагрузку на API. При 1–2 символах результатов обычно много и нерелевантно.

---

### Бесконечный скролл

**Как реализован бесконечный скролл?**  
Через Intersection Observer. Создаю ref на блок внизу списка. Когда он попадает в viewport, вызываю `fetchNextPage()` из useInfiniteQuery. При размонтировании отписываюсь от observer.

---

### TypeScript

**Как типизированы данные с API?**  
В `shared/types/movie.ts` описаны интерфейсы Movie, MovieDetails, MovieSearchResponse под структуру TMDB. API-методы возвращают эти типы, компоненты получают типизированные данные.

---

### Тестирование (если спросят)

**Есть ли тесты?**  
В рамках тестового задания тесты не делала. В реальном проекте добавила бы unit-тесты для API и компонентов, e2e для ключевых сценариев.

---

### Что бы улучшила

- Добавить unit/e2e тесты
- Реализовать фильтр по жанрам
- Вынести текст в i18n для локализации
- Добавить error boundary для глобальных ошибок
- Оптимизировать изображения (priority, lazy loading)

---

## Часть 3. Полезные фразы для защиты

- «Я организовала проект по Feature-Sliced Design, чтобы сохранять низкую связанность между модулями.»
- «Серверные данные управляются через React Query: кеш, loading и error обрабатываются автоматически.»
- «Клиентское состояние — поиск и тема — вынесла в Zustand с persist для темы.»
- «Поиск оптимизирован через debounce, чтобы не создавать лишних запросов к API.»
- «Бесконечный скролл реализован на Intersection Observer и useInfiniteQuery.»
- «Динамический роут `/movie/[id]` позволяет получать детали любого фильма по его идентификатору.»

Удачи на защите.
